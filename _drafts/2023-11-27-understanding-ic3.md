---
layout: post
title:  "Understanding IC3"
categories: formal-methods model-checking
---

<!-- $$ -->
<!-- Init \wedge \square [Next]_{vars} \wedge Liveness -->
<!-- $$ -->

To verify the safety of a discrete transition system, the simplest approach is to perform some kind of *reachability analysis*. That is, we simply try to explore all possible states reachable from the initial states, or, alternatively, work backwards from bad states (those violating a target safety property), and see if we can make our way back to an initial state. 

This is a practical technique, especially given its simplicity, but for systems beyond a certain complexity, it is fundamentally incomplete, since, for infinite state systems, or even finite systems that are large enough, we cannot feasibly explore all possible system states. Thus, for large scale verification, the core problem is centered around development of an *inductive invariant* which, in theory, allows us to verify arbitrarily large systems (even infinite state ones), if we are able to develop a suitable inductive assertion. So, most modern model checking algorithms are centered around this core task i.e. synthesizing an inductive invariant as a core part of the model checking algorithm.

IC3/PDR is a model checking algorithm developed around 2011 by Aaron Bradley, a student of Zohar Manna, and is currently considered to be a state of the art model checking algorithm for proving properties about transition systems. In some respects, we can see IC3/PDR as a clumination of a lineage of symbolic, SAT-based model checking techniques that go back to initial approaches on bounded model checking (BMC), followed by k-induction and interpolation.

IC3 is a complete algorithm for finite state systems. So, from this, it can be understood alternately as both (1) a proof search technique as well as (2) a bug finder. Both of these components of the algorithm work in parallel, with the goal of either producing an inductive invariant if the system is safe, or finding a concrete counterexample trace if the system violates a target safety property. It is instructive to understand how other complete algorithms operate along these two axes as well, to see how they differ from IC3. For example, k-induction can be viewed as a interleaved combination of forward BMC with a k-induction check, for increasing bounds of $$k$$. If a bug exists, it will exist for some bound, and so BMC will discover the bug. And, if the system is safe, then there will exists some $$k$$ for which the target safety property is safe.  Note that even BMC can, on its own, be made complete, if we know an exact or upper bound on the *reachability diameter* i.e., the minimal number of steps required to reach all states. A naive bound can simply be the total number of possible states based on the number of state variables (e.g. assuming boolean transition systems). For real world systems, this is infeasible, so BMC in isolation is typically, an incomplete technique, unless you combine it with the k-induction trick.


## How IC3 Works

To understand the basic mechanisms of IC3, we can look at an example of how it develops an inductive invariant for a simple example transition system. We can use a simple "lock server" system as a starting example, which is a very simple distributed protocol, but can be easily encoded as a boolean transition system. It consists of a set of clients and a set of servers, and each server maintains a semaphore that can be claimed by some client and returned to that server the same client. The safety property is that no two clients hold the semaphore of the same server simultaneously. 

We can examine the progression of frames, clause propagation, and the final inductive invariant generated by a basic run of IC3 on this protocol for small, fixed parameters.

<!-- 
#### My Questions

- Can we transform a non machine closed spec into a machine closed one? How does this affect $$S$$ and $$L$$?
- Why do we use temporal properties at all for specification? Why not just always stick with the automaton/state machine technique of specification? 
- In what cases is it useful to write non machine closed specifications?
- Does the liveness property of a non machine closed spec always rule out *all* allowed behaviors, or only some? In general, it should only rule out some. -->

----
<!-- 
If we have a spec 

$$ 
\begin{aligned}
S &\triangleq  x=0 \wedge \square [x'=x+1]_x \\
L & \triangleq (x>3 \Rightarrow \Diamond x'=x-1)
\end{aligned}
$$

this is clearly not machine closed since we have prefixes like `<<1,2,3,4>>` which are safe but cannot be extended to satisfy $$L$$. On the other hand, there are some safe prefixes like `<<1,2,3>>` which are safe and can be extended to satisfy $$L$$ i.e. by stuttering forever. So, our allowed prefixes should be those which never exceed 3 i.e.

```
<<1>>
<<1,2>>
<<1,2,3>>
```

So, we should be able to decompose this non machine closed spec into a different, machine closed spec $$(S',L')$$ that permits the same set of behaviors. For example:

$$ 
\begin{aligned}
S &\triangleq  x=0 \wedge \square [x < 3 \wedge x'=x+1]_x \\
L & \triangleq True
\end{aligned}
$$

We've changed the safety property to prevent us ever incrementing $$x$$ beyond a value of $$3$$, and we've removed our liveness property entirely. To do this we strengthened our safety property (i.e. it allows fewer behaviors, taken on its own), and we weakened our liveness property (i.e. it allows more behaviors). -->
